<p><strong>Queryset</strong> can be constructed, filtered, sliced, and generally passed around without actually hitting the database. No database activity actually occurs until you do something to evaluate the queryset.</p>

<p>Querysets are evaluated when</p>

<ol>
  <li>iterated</li>
  <li>slice</li>
  <li>pickle</li>
  <li>repr</li>
  <li>len</li>
  <li>list</li>
  <li>bool</li>
</ol>

<ul>
  <li>Filter:Returns a new QuerySet containing objects that match the given lookup parameters.</li>
  <li>Exclude: Returns a new <code class="highlighter-rouge">QuerySet</code> containing objects that do <em>not</em> match the given lookup parameters. In sql SELECT …WHERE NOT..</li>
  <li>Annotate</li>
</ul>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="o">&gt;&gt;&gt;</span> <span class="kn">from</span> <span class="nn">django.db.models</span> <span class="kn">import</span> <span class="n">Count</span>
  <span class="o">&gt;&gt;&gt;</span> <span class="n">q</span> <span class="o">=</span> <span class="n">Blog</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">annotate</span><span class="p">(</span><span class="n">Count</span><span class="p">(</span><span class="s">'entry'</span><span class="p">))</span>
  \<span class="c"># The name of the first blog</span>
  <span class="o">&gt;&gt;&gt;</span> <span class="n">q</span>\<span class="p">[</span><span class="mi">0</span>\<span class="p">]</span><span class="o">.</span><span class="n">name</span>
  \<span class="s">'Blogasaurus'</span>
  \<span class="c"># The number of entries on the first blog</span>
  <span class="o">&gt;&gt;&gt;</span> <span class="n">q</span>\<span class="p">[</span><span class="mi">0</span>\<span class="p">]</span><span class="o">.</span><span class="n">entry__count</span>
  <span class="mi">42</span>
</code></pre></div></div>

<ul>
  <li>order_by</li>
  <li>reverse</li>
  <li>
    <p>distinct</p>

    <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Entry.objects.order_by('pub_date').distinct('pub_date')
</code></pre></div>    </div>
  </li>
  <li>
    <p>values</p>

    <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Blog.objects.values()
&lt;QuerySet [{'id': 1, 'name': 'Beatles Blog', 'tagline': 'All the latest Beatles news.'}]&gt;
  
Blog.objects.values('id', 'name')
&lt;QuerySet [{'id': 1, 'name': 'Beatles Blog'}]&gt;
  
Blog.objects.values(lower_name=Lower('name'))
&lt;QuerySet [{'lower_name': 'beatles blog'}]&gt;
</code></pre></div>    </div>
  </li>
  <li>
    <p>value_list</p>

    <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&gt;&gt;&gt; Entry.objects.values_list('id', 'headline')
&lt;QuerySet [(1, 'First entry'), ...]&gt;
&gt;&gt;&gt; from django.db.models.functions import Lower
&gt;&gt;&gt; Entry.objects.values_list('id', Lower('headline'))
&lt;QuerySet [(1, 'first entry'), ...]&gt;
</code></pre></div>    </div>
  </li>
  <li>
    <p>dates and datetimes</p>

    <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&gt;&gt;&gt; Entry.objects.dates('pub_date', 'year')
[datetime.date(2005, 1, 1)]
&gt;&gt;&gt; Entry.objects.dates('pub_date', 'month')
[datetime.date(2005, 2, 1), datetime.date(2005, 3, 1)]
&gt;&gt;&gt; Entry.objects.dates('pub_date', 'day')
[datetime.date(2005, 2, 20), datetime.date(2005, 3, 20)]
&gt;&gt;&gt; Entry.objects.dates('pub_date', 'day', order='DESC')
[datetime.date(2005, 3, 20), datetime.date(2005, 2, 20)]
&gt;&gt;&gt; Entry.objects.filter(headline__contains='Lennon').dates('pub_date', 'day')
[datetime.date(2005, 3, 20)]
</code></pre></div>    </div>
  </li>
  <li>all</li>
  <li>
    <p>union, intersection, difference</p>

    <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>qs1.union(qs2, qs3)
qs1.intersection(qs2, qs3)
qs1.difference(qs2, qs3)
</code></pre></div>    </div>
  </li>
  <li>
    <p>Select_related: Returns a <code class="highlighter-rouge">QuerySet</code> that will “follow” foreign-key relationships, selecting additional related-object data when it executes its query. This is a performance booster which results in a single more complex query but means later use of foreign-key relationships won’t require database queries</p>

    <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code># Hits the database.
e = Entry.objects.select_related('blog').get(id=5)
  
# Doesn't hit the database, because e.blog has been prepopulated
# in the previous query.
b = e.blog
</code></pre></div>    </div>
  </li>
  <li>
    <p>Prefetch related: similar to select_realted</p>

    <p><code class="highlighter-rouge">select_related</code> works by creating an SQL join and including the fields of the related object in the <code class="highlighter-rouge">SELECT</code> statement. For this reason, <code class="highlighter-rouge">select_related</code> gets the related objects in the same database query. However, to avoid the much larger result set that would result from joining across a ‘many’ relationship, <code class="highlighter-rouge">select_related</code> is limited to single-valued relationships - foreign key and one-to-one.</p>

    <p><code class="highlighter-rouge">prefetch_related</code>, on the other hand, does a separate lookup for each relationship, and does the ‘joining’ in Python. This allows it to prefetch many-to-many and many-to-one objects, which cannot be done using <code class="highlighter-rouge">select_related</code>, in addition to the foreign key and one-to-one relationships that are supported by <code class="highlighter-rouge">select_related</code>.</p>

    <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code># This is all possible
Restaurant.objects.prefetch_related('best_pizza__toppings')
Restaurant.objects.select_related('best_pizza').prefetch_related('best_pizza__toppings')
</code></pre></div>    </div>
  </li>
  <li>
    <p>Extra: Sometimes, the Django query syntax by itself can’t easily express a complex <code class="highlighter-rouge">WHERE</code> clause. For these edge cases, Django provides the <code class="highlighter-rouge">extra()</code> <code class="highlighter-rouge">QuerySet</code> modifier — a hook for injecting specific clauses into the SQL generated by a <code class="highlighter-rouge">QuerySet</code>.</p>

    <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code># Select example
qs.extra(select={'val': "select col from sometable where othercol = %s"},
         select_params=(someparam,))
  
# Where example
Entry.objects.extra(where=["foo='a' OR bar = 'a'", "baz = 'a'"])
  
# order by
q = q.extra(order_by = ['-is_recent'])
</code></pre></div>    </div>
  </li>
  <li>
    <p>Defer: In some complex data-modeling situations, your models might contain a lot of fields, some of which could contain a lot of data (for example, text fields), or require expensive processing to convert them to Python objects. If you are using the results of a queryset in some situation where you don’t know if you need those particular fields when you initially fetch the data, you can tell Django not to retrieve them from the database</p>

    <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code># Simple defer
Entry.objects.defer("headline", "body")
  
# complex defer
Blog.objects.select_related().defer("entry__headline", "entry__body")
</code></pre></div>    </div>
  </li>
  <li>Only: Opposite to defer</li>
  <li>Using: when using multiple databases</li>
  <li>Select___for__u_pda_te: selects rows and locks them for update</li>
  <li>Raw: Takes a raw SQL query, executes it</li>
  <li>Get</li>
  <li>Create</li>
  <li>update</li>
  <li>delete</li>
  <li>get <em>or create and update or create</em></li>
  <li>bulk_create</li>
  <li>count</li>
  <li>in_bulk: to get multiple entries in bulk</li>
  <li><strong>OuterRef:</strong> Use <code class="highlighter-rouge">OuterRef</code> when a queryset in a <code class="highlighter-rouge">Subquery</code> needs to refer to a field from the outer query. It acts like an <code class="highlighter-rouge">[F](https://docs.djangoproject.com/en/2.0/ref/models/expressions/#django.db.models.F "django.db.models.F")</code> expression except that the check to see if it refers to a valid field isn’t made until the outer queryset is resolved.</li>
  <li>
    <p>Latest</p>

    <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Entry.objects.latest('pub_date', '-expire_date')
</code></pre></div>    </div>
  </li>
  <li>first and last</li>
  <li>
    <p>Aggregate:</p>

    <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code> Book.objects.aggregate(Avg('price'), Max('price'), Min('price'))
</code></pre></div>    </div>
  </li>
  <li>
    <p>Annotate</p>

    <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>q = Book.objects.annotate(Count('authors'))
# Interrogate the first object in the queryset
&gt;&gt;&gt; q[0]
&lt;Book: The Definitive Guide to Django&gt;
&gt;&gt;&gt; q[0].authors__count
2
# Interrogate the second object in the queryset
&gt;&gt;&gt; q[1]
&lt;Book: Practical Django Projects&gt;
&gt;&gt;&gt; q[1].authors__count
1
</code></pre></div>    </div>
  </li>
  <li>
    <p>Follow relationships backwards ( how we use <code class="highlighter-rouge">'book'</code> to specify the <code class="highlighter-rouge">Publisher</code> -&gt; <code class="highlighter-rouge">Book</code> reverse foreign key hop))</p>

    <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Publisher.objects.aggregate(oldest_pubdate=Min('book__pubdate'))
</code></pre></div>    </div>
  </li>
  <li>
    <p>Filter on annotation</p>

    <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Book.objects.annotate(num_authors=Count('authors')).filter(num_authors__gt=1)
</code></pre></div>    </div>
  </li>
  <li>
    <p>Q objects (Logical operations)</p>

    <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Q(question__startswith='Who') | Q(question__startswith='What')
Poll.objects.get(
    Q(question__startswith='Who'),
    Q(pub_date=date(2005, 5, 2)) | Q(pub_date=date(2005, 5, 6))
)
</code></pre></div>    </div>
  </li>
  <li>
    <p>F expressions: act as a reference to a model field within a query</p>

    <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&gt;&gt;&gt; from django.db.models import F
&gt;&gt;&gt; Entry.objects.filter(n_comments__gt=F('n_pingbacks'))
</code></pre></div>    </div>
  </li>
  <li>
    <p><code class="highlighter-rouge">Subquery()</code> expressions</p>

    <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&gt;&gt;&gt; from django.db.models import OuterRef, Subquery
&gt;&gt;&gt; newest = Comment.objects.filter(post=OuterRef('pk')).order_by('-created_at')
&gt;&gt;&gt; Post.objects.annotate(newest_commenter_email=Subquery(newest.values('email')[:1]))
</code></pre></div>    </div>
  </li>
</ul>

<h5 id="learn-complex-queries-by-examples">Learn COMPLEX queries by examples:</h5>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code># Group by date
Log.objects.order_by().annotate(date=TruncDate('created_at')).values('date').annotate(c=Count('id'))

# Annotating Django querysets with ForeignKey Counts subject to conditions

Airport.objects.filter(
    Q(origins__owner=user) | Q(destinations__owner=user)
).annotate(
    num_origins=Count(
        Case(When(Q(origin__owner=user), then=1, else=0)),
    ),
    num_destinations=Count(
        Case(When(Q(destination__owner=user), then=1, else=0)),
    )
)

# Aggrigate	
Feedback.objects.aggregate(avg_rating=Avg('rating'))

Parent.objects
.annotate(child_count=Count('child'))
.annotate(
    grandchild_count_for_state_true=Subquery(
        GrandChild.objects.filter(
            state=True,
            child=OuterRef('pk')
        ).values('parent')
        .annotate(cnt=Sum('child__grandchild__num'))
        .values('cnt'),
        num=models.IntegerField()
    )
)
</code></pre></div></div>

<p>WINDOW: Window functions provide a way to apply functions on partitions. Unlike a normal aggregation function which computes a final result for each set defined by the group by, window functions operate on <a href="https://docs.djangoproject.com/en/2.0/ref/models/expressions/#window-frames">frames</a> and partitions, and compute the result for each row.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&gt;&gt;&gt; from django.db.models import Avg, F, RowRange, Window
&gt;&gt;&gt; from django.db.models.functions import ExtractYear
&gt;&gt;&gt; Movie.objects.annotate(
&gt;&gt;&gt;     avg_rating=Window(
&gt;&gt;&gt;         expression=Avg('rating'),
&gt;&gt;&gt;         partition_by=[F('studio'), F('genre')],
&gt;&gt;&gt;         order_by=ExtractYear('released').asc(),
&gt;&gt;&gt;         frame=RowRange(start=-2, end=2),
&gt;&gt;&gt;     ),
&gt;&gt;&gt; )
</code></pre></div></div>

<p><code class="highlighter-rouge">**Exists:**</code>is a <code class="highlighter-rouge">Subquery</code> subclass that uses an SQL <code class="highlighter-rouge">EXISTS</code> statement. In many cases it will perform better than a subquery since the database is able to stop evaluation of the subquery when a first matching row is found.</p>

<p>For example, to annotate each post with whether or not it has a comment from within the last day:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&gt;&gt;&gt; from django.db.models import Exists, OuterRef
&gt;&gt;&gt; from datetime import timedelta
&gt;&gt;&gt; from django.utils import timezone
&gt;&gt;&gt; one_day_ago = timezone.now() - timedelta(days=1)
&gt;&gt;&gt; recent_comments = Comment.objects.filter(
...     post=OuterRef('pk'),
...     created_at__gte=one_day_ago,
... )
&gt;&gt;&gt; Post.objects.annotate(recent_comment=Exists(recent_comments))
</code></pre></div></div>

<p><code class="highlighter-rouge">Exists</code> is a <code class="highlighter-rouge">Subquery</code> subclass that uses an SQL <code class="highlighter-rouge">EXISTS</code> statement. In many cases it will perform better than a subquery since the database is able to stop evaluation of the subquery when a first matching row is found.</p>

<p>For example, to annotate each post with whether or not it has a comment from within the last day:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&gt;&gt;&gt; from django.db.models import Exists, OuterRef
&gt;&gt;&gt; from datetime import timedelta
&gt;&gt;&gt; from django.utils import timezone
&gt;&gt;&gt; one_day_ago = timezone.now() - timedelta(days=1)
&gt;&gt;&gt; recent_comments = Comment.objects.filter(
...     post=OuterRef('pk'),
...     created_at__gte=one_day_ago,
... )
&gt;&gt;&gt; Post.objects.annotate(recent_comment=Exists(recent_comments))
</code></pre></div></div>

<p>more examples</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>from django.db.models.functions import Concat
from django.db.models import F, Value

qs = qs.annotate(fullname=Concat(F('name'), Value(' '), F('surname')))\
            .filter(fullname__icontains=textquery)
</code></pre></div></div>

<p>If you want to write django queries try answering these questions in django ORM</p>

<p><a href="http://a4academics.com/interview-questions/53-database-and-sql/397-top-100-database-sql-interview-questions-and-answers-examples-queries?showall=&amp;start=2" title="http://a4academics.com/interview-questions/53-database-and-sql/397-top-100-database-sql-interview-questions-and-answers-examples-queries?showall=&amp;start=2">http://a4academics.com/interview-questions/53-database-and-sql/397-top-100-database-sql-interview-questions-and-answers-examples-queries?showall=&amp;start=2</a></p>

<p>References:</p>

<p>Django documentaion</p>

<p><a href="https://stackoverflow.com/questions/8746014/django-group-by-date-day-month-year" title="https://stackoverflow.com/questions/8746014/django-group-by-date-day-month-year">https://stackoverflow.com/questions/8746014/django-group-by-date-day-month-year</a></p>

<p><a href="https://stackoverflow.com/questions/48301339/group-by-each-date-in-django-2" title="https://stackoverflow.com/questions/48301339/group-by-each-date-in-django-2">https://stackoverflow.com/questions/48301339/group-by-each-date-in-django-2</a></p>

<p><a href="https://stackoverflow.com/questions/tagged/django-queryset" title="https://stackoverflow.com/questions/tagged/django-queryset">https://stackoverflow.com/questions/tagged/django-queryset</a></p>
