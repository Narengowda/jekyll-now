<p><code class="highlighter-rouge">QuerySet</code> can be constructed, filtered, sliced, and generally passed around without actually hitting the database. No database activity actually occurs until you do something to evaluate the queryset.</p>

<p>Querysets are evaluated when</p>

<ol>
  <li>iterated</li>
  <li>slice</li>
  <li>pickle</li>
  <li>repr</li>
  <li>len</li>
  <li>list</li>
  <li>bool</li>
</ol>

<ul>
  <li>Filter:Returns a new QuerySet containing objects that match the given lookup parameters.</li>
  <li>Exclude: Returns a new <code class="highlighter-rouge">QuerySet</code> containing objects that do <em>not</em> match the given lookup parameters. In sql SELECT …WHERE NOT..</li>
  <li>Annotate</li>
</ul>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="o">&gt;&gt;&gt;</span> <span class="kn">from</span> <span class="nn">django.db.models</span> <span class="kn">import</span> <span class="n">Count</span>
  <span class="o">&gt;&gt;&gt;</span> <span class="n">q</span> <span class="o">=</span> <span class="n">Blog</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">annotate</span><span class="p">(</span><span class="n">Count</span><span class="p">(</span><span class="s">'entry'</span><span class="p">))</span>
  \<span class="c"># The name of the first blog</span>
  <span class="o">&gt;&gt;&gt;</span> <span class="n">q</span>\<span class="p">[</span><span class="mi">0</span>\<span class="p">]</span><span class="o">.</span><span class="n">name</span>
  \<span class="s">'Blogasaurus'</span>
  \<span class="c"># The number of entries on the first blog</span>
  <span class="o">&gt;&gt;&gt;</span> <span class="n">q</span>\<span class="p">[</span><span class="mi">0</span>\<span class="p">]</span><span class="o">.</span><span class="n">entry__count</span>
  <span class="mi">42</span>
</code></pre></div></div>

<ul>
  <li>order_by</li>
  <li>reverse</li>
  <li>
    <p>distinct</p>

    <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Entry.objects.order_by('pub_date').distinct('pub_date')
</code></pre></div>    </div>
  </li>
  <li>
    <p>values</p>

    <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Blog.objects.values()
&lt;QuerySet [{'id': 1, 'name': 'Beatles Blog', 'tagline': 'All the latest Beatles news.'}]&gt;
  
Blog.objects.values('id', 'name')
&lt;QuerySet [{'id': 1, 'name': 'Beatles Blog'}]&gt;
  
Blog.objects.values(lower_name=Lower('name'))
&lt;QuerySet [{'lower_name': 'beatles blog'}]&gt;
</code></pre></div>    </div>
  </li>
  <li>
    <p>value_list</p>

    <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&gt;&gt;&gt; Entry.objects.values_list('id', 'headline')
&lt;QuerySet [(1, 'First entry'), ...]&gt;
&gt;&gt;&gt; from django.db.models.functions import Lower
&gt;&gt;&gt; Entry.objects.values_list('id', Lower('headline'))
&lt;QuerySet [(1, 'first entry'), ...]&gt;
</code></pre></div>    </div>
  </li>
  <li>
    <p>dates and datetimes</p>

    <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&gt;&gt;&gt; Entry.objects.dates('pub_date', 'year')
[datetime.date(2005, 1, 1)]
&gt;&gt;&gt; Entry.objects.dates('pub_date', 'month')
[datetime.date(2005, 2, 1), datetime.date(2005, 3, 1)]
&gt;&gt;&gt; Entry.objects.dates('pub_date', 'day')
[datetime.date(2005, 2, 20), datetime.date(2005, 3, 20)]
&gt;&gt;&gt; Entry.objects.dates('pub_date', 'day', order='DESC')
[datetime.date(2005, 3, 20), datetime.date(2005, 2, 20)]
&gt;&gt;&gt; Entry.objects.filter(headline__contains='Lennon').dates('pub_date', 'day')
[datetime.date(2005, 3, 20)]
</code></pre></div>    </div>
  </li>
  <li>all</li>
  <li>
    <p>union, intersection, difference</p>

    <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>qs1.union(qs2, qs3)
qs1.intersection(qs2, qs3)
qs1.difference(qs2, qs3)
</code></pre></div>    </div>
  </li>
  <li>
    <p>Select_related: Returns a <code class="highlighter-rouge">QuerySet</code> that will “follow” foreign-key relationships, selecting additional related-object data when it executes its query. This is a performance booster which results in a single more complex query but means later use of foreign-key relationships won’t require database queries</p>

    <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code># Hits the database.
e = Entry.objects.select_related('blog').get(id=5)
  
# Doesn't hit the database, because e.blog has been prepopulated
# in the previous query.
b = e.blog
</code></pre></div>    </div>
  </li>
  <li>
    <p>Prefetch related: similar to select_realted</p>

    <p><code class="highlighter-rouge">select_related</code> works by creating an SQL join and including the fields of the related object in the <code class="highlighter-rouge">SELECT</code> statement. For this reason, <code class="highlighter-rouge">select_related</code> gets the related objects in the same database query. However, to avoid the much larger result set that would result from joining across a ‘many’ relationship, <code class="highlighter-rouge">select_related</code> is limited to single-valued relationships - foreign key and one-to-one.</p>

    <p><code class="highlighter-rouge">prefetch_related</code>, on the other hand, does a separate lookup for each relationship, and does the ‘joining’ in Python. This allows it to prefetch many-to-many and many-to-one objects, which cannot be done using <code class="highlighter-rouge">select_related</code>, in addition to the foreign key and one-to-one relationships that are supported by <code class="highlighter-rouge">select_related</code>.</p>

    <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code># This is all possible
Restaurant.objects.prefetch_related('best_pizza__toppings')
Restaurant.objects.select_related('best_pizza').prefetch_related('best_pizza__toppings')
</code></pre></div>    </div>
  </li>
  <li>
    <p>Extra: Sometimes, the Django query syntax by itself can’t easily express a complex <code class="highlighter-rouge">WHERE</code> clause. For these edge cases, Django provides the <code class="highlighter-rouge">extra()</code> <code class="highlighter-rouge">QuerySet</code> modifier — a hook for injecting specific clauses into the SQL generated by a <code class="highlighter-rouge">QuerySet</code>.</p>

    <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code># Select example
qs.extra(select={'val': "select col from sometable where othercol = %s"},
         select_params=(someparam,))
  
# Where example
Entry.objects.extra(where=["foo='a' OR bar = 'a'", "baz = 'a'"])
  
# order by
q = q.extra(order_by = ['-is_recent'])
</code></pre></div>    </div>
  </li>
  <li>
    <p>Defer: In some complex data-modeling situations, your models might contain a lot of fields, some of which could contain a lot of data (for example, text fields), or require expensive processing to convert them to Python objects. If you are using the results of a queryset in some situation where you don’t know if you need those particular fields when you initially fetch the data, you can tell Django not to retrieve them from the database</p>

    <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code># Simple defer
Entry.objects.defer("headline", "body")
  
# complex defer
Blog.objects.select_related().defer("entry__headline", "entry__body")
</code></pre></div>    </div>
  </li>
  <li>Only: Opposite to defer</li>
  <li>Using: when using multiple databases</li>
  <li>Select___for__u_pda_te: selects rows and locks them for update</li>
  <li>Raw: Takes a raw SQL query, executes it</li>
  <li>Get</li>
  <li>Create</li>
  <li>update</li>
  <li>delete</li>
  <li>get <em>or create and update or create</em></li>
  <li>bulk_create</li>
  <li>count</li>
  <li>in_bulk: to get multiple entries in bulk</li>
  <li>
    <p>Latest</p>

    <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Entry.objects.latest('pub_date', '-expire_date')
</code></pre></div>    </div>
  </li>
  <li>first and last</li>
  <li>
    <p>Aggregte:</p>

    <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code> Book.objects.aggregate(Avg('price'), Max('price'), Min('price'))
</code></pre></div>    </div>
  </li>
  <li>
    <p>Annotate</p>

    <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>q = Book.objects.annotate(Count('authors'))
# Interrogate the first object in the queryset
&gt;&gt;&gt; q[0]
&lt;Book: The Definitive Guide to Django&gt;
&gt;&gt;&gt; q[0].authors__count
2
# Interrogate the second object in the queryset
&gt;&gt;&gt; q[1]
&lt;Book: Practical Django Projects&gt;
&gt;&gt;&gt; q[1].authors__count
1
</code></pre></div>    </div>
  </li>
  <li>
    <p>Follow relationships backwards ( how we use <code class="highlighter-rouge">'book'</code> to specify the <code class="highlighter-rouge">Publisher</code> -&gt; <code class="highlighter-rouge">Book</code> reverse foreign key hop))</p>

    <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Publisher.objects.aggregate(oldest_pubdate=Min('book__pubdate'))
</code></pre></div>    </div>
  </li>
  <li>
    <p>Filter on annotation</p>

    <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Book.objects.annotate(num_authors=Count('authors')).filter(num_authors__gt=1)
</code></pre></div>    </div>
  </li>
  <li>
    <p>Q objects (Logical operations)</p>

    <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Q(question__startswith='Who') | Q(question__startswith='What')
Poll.objects.get(
    Q(question__startswith='Who'),
    Q(pub_date=date(2005, 5, 2)) | Q(pub_date=date(2005, 5, 6))
)
</code></pre></div>    </div>
  </li>
  <li>
    <p>F expressions: act as a reference to a model field within a query</p>

    <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&gt;&gt;&gt; from django.db.models import F
&gt;&gt;&gt; Entry.objects.filter(n_comments__gt=F('n_pingbacks'))
</code></pre></div>    </div>
  </li>
</ul>

<h3 id="field-lookups">Field lookups:</h3>
